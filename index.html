<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Visualizer v5 - Fullscreen Fixed</title>
    <style>
        :root { --accent: #00f2ff; --bg: #000; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); overflow: hidden; font-family: 'Segoe UI', sans-serif;
            touch-action: none; 
        }
        canvas { position: absolute; top: 0; left: 0; display: block; width: 100%; height: 100%; cursor: none; }

        /* UI Layer */
        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; 
            z-index: 100; background: rgba(0, 0, 0, 0.85); padding: 12px; 
            border-radius: 20px; backdrop-filter: blur(20px);
            width: 95%; max-width: 700px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
            border: 1px solid rgba(255,255,255,0.1);
            opacity: 1;
        }

        /* VOLLBILD LOGIK: UI komplett weg, wenn aktiv */
        body.is-fullscreen .ui-layer { opacity: 0; pointer-events: none; transform: translate(-50%, 100px); }
        
        /* UI kurz zeigen bei Interaktion im Vollbild */
        body.is-fullscreen.show-ui .ui-layer { opacity: 1; pointer-events: auto; transform: translate(-50%, 0); }

        button {
            background: rgba(255,255,255,0.1); border: none; color: #fff;
            padding: 10px; border-radius: 10px; cursor: pointer; 
            font-size: 10px; flex: 1 1 65px; text-transform: uppercase;
            transition: 0.2s;
        }
        button.active { background: var(--accent); color: #000; font-weight: bold; box-shadow: 0 0 15px var(--accent); }
        button.fs-toggle { background: rgba(0, 242, 255, 0.2); border: 1px solid var(--accent); flex: 1 1 100px; }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 200;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; cursor: pointer; text-align: center;
        }

        .hint { 
            position: fixed; top: 15px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.3); font-size: 10px; z-index: 5;
            pointer-events: none; text-transform: uppercase; letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div id="start-screen" onclick="initApp()">
        <h1 style="letter-spacing: 12px; font-weight: 200; margin-bottom: 15px;">V I S U A L I Z E R</h1>
        <p style="color: var(--accent); font-size: 14px;">KLICKEN ZUM STARTEN</p>
        <p style="font-size: 10px; opacity: 0.5; margin-top: 20px;">Bildschirm bleibt an • Telefon-Modus blockiert</p>
    </div>

    <div class="hint">TAP: WECHSELN | 'F': VOLLBILD</div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <button onclick="setMode(0, event)">Bars</button>
        <button onclick="setMode(1, event)">Wave</button>
        <button onclick="setMode(2, event)">Radial</button>
        <button onclick="setMode(3, event)">Nebula</button>
        <button onclick="setMode(4, event)">Spiral</button>
        <button onclick="setMode(5, event)">Mirror</button>
        <button onclick="setMode(6, event)">Flower</button>
        <button onclick="setMode(7, event)">Matrix</button>
        <button onclick="setMode(8, event)">DNA</button>
        <button onclick="setMode(9, event)">Tunnel</button>
        <button onclick="setMode(10, event)">Orbit</button>
        <button onclick="setMode(11, event)">Peak</button>
        <button onclick="toggleFS(event)" class="fs-toggle">VOLLBILD AN/AUS</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioCtx, analyser, dataArray, source, wakeLock = null;
        let mode = 0;
        let hue = 0;
        let uiTimeout;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        async function initApp() {
            if (audioCtx) return;

            // Screen Wake Lock
            if ('wakeLock' in navigator) {
                try { wakeLock = await navigator.wakeLock.request('screen'); } catch (e) {}
            }

            try {
                // Telefon-Modus verhindern (echoCancellation: false)
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } 
                });

                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.85;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                source.connect(analyser);

                document.getElementById('start-screen').style.display = 'none';
                updateUI();
                draw();
            } catch (err) { alert("Mikrofon-Zugriff erforderlich."); }
        }

        // Modus-Wechsel per Pointer (verhindert Mehrfach-Trigger auf Mobile)
        window.addEventListener('pointerdown', (e) => {
            if(e.target.tagName !== 'BUTTON' && audioCtx) {
                mode = (mode + 1) % 12;
                updateUI();
            }
            showUI();
        });

        function setMode(m, e) {
            e.stopPropagation();
            mode = m;
            updateUI();
        }

        function updateUI() {
            const btns = document.querySelectorAll('button');
            btns.forEach((b, i) => { if(i < 12) b.classList.toggle('active', i === mode); });
        }

        // ECHTER VOLLBILD MODUS
        function toggleFS(e) {
            if(e) e.stopPropagation();
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => {});
                document.body.classList.add('is-fullscreen');
            } else {
                document.exitFullscreen();
                document.body.classList.remove('is-fullscreen');
            }
        }

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) document.body.classList.remove('is-fullscreen');
            else document.body.classList.add('is-fullscreen');
        });

        window.addEventListener('keydown', e => { if(e.key.toLowerCase() === 'f') toggleFS(); });

        // UI Einblenden bei Bewegung
        function showUI() {
            document.body.classList.add('show-ui');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => document.body.classList.remove('show-ui'), 3000);
        }
        window.addEventListener('mousemove', showUI);
        window.addEventListener('touchstart', showUI);

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);
            const w = window.innerWidth, h = window.innerHeight;
            const cx = w/2, cy = h/2;

            // Hintergrund mit Fade für "Smoothness" ohne Rückstände
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, w, h);
            hue += 0.5;

            // Render Modi
            if(mode === 0) { // Modern Bars
                const count = 64; const bw = w / count;
                for(let i=0; i<count; i++) {
                    const v = (dataArray[i*4]/255)*h*0.7;
                    ctx.fillStyle = `hsla(${hue+i*5},70%,50%,0.8)`;
                    ctx.fillRect(i*bw, h-v, bw-2, v);
                }
            } else if(mode === 1) { // Waveform
                analyser.getByteTimeDomainData(dataArray);
                ctx.beginPath(); ctx.strokeStyle=`hsla(${hue},100%,60%,1)`; ctx.lineWidth=3;
                for(let i=0; i<dataArray.length; i++) {
                    const x = (i/dataArray.length)*w; const y = (dataArray[i]/128)*cy;
                    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
                ctx.stroke();
            } else if(mode === 2) { // Radial
                for(let i=0; i<120; i++) {
                    const a = i * Math.PI/60; const l = (dataArray[i]/255)*h*0.25;
                    ctx.strokeStyle=`hsla(${hue+i*2},80%,50%,0.8)`; ctx.lineWidth=4; ctx.lineCap="round";
                    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*(h*0.1+l), cy+Math.sin(a)*(h*0.1+l)); ctx.stroke();
                }
            } else if(mode === 3) { // Nebula Pulse
                const b = dataArray[2]/255; const g = ctx.createRadialGradient(cx,cy,0,cx,cy,b*h*0.7);
                g.addColorStop(0, `hsla(${hue},80%,50%,0.7)`); g.addColorStop(1, 'transparent');
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,b*h*0.7,0,Math.PI*2); ctx.fill();
            } else if(mode === 4) { // Spiral Dots
                for(let i=0; i<150; i++) {
                    const a = i*0.2 + hue*0.05; const r = i*3 + dataArray[i%50]*0.2;
                    ctx.fillStyle=`hsla(${hue+i*2},70%,60%,0.8)`;
                    ctx.beginPath(); ctx.arc(cx+Math.cos(a)*r, cy+Math.sin(a)*r, dataArray[i%50]/25+1, 0, Math.PI*2); ctx.fill();
                }
            } else if(mode === 5) { // Mirror Central
                const bw = (w/2)/40;
                for(let i=0; i<40; i++) {
                    const v = (dataArray[i*2]/255)*cy;
                    ctx.fillStyle=`hsla(${hue+i*4},70%,50%,0.8)`;
                    ctx.fillRect(cx+i*bw, cy-v/2, bw-1, v); ctx.fillRect(cx-i*bw, cy-v/2, bw-1, v);
                }
            } else if(mode === 6) { // Flower Geometry
                ctx.save(); ctx.translate(cx,cy); ctx.rotate(hue*0.01);
                for(let i=0; i<8; i++) {
                    ctx.rotate(Math.PI/4); const v = dataArray[i*10];
                    ctx.strokeStyle=`hsla(${hue+i*30},80%,60%,0.8)`; ctx.strokeRect(-v/2,-v/2,v,v);
                }
                ctx.restore();
            } else if(mode === 7) { // Matrix Rain
                ctx.font="bold 16px monospace";
                for(let i=0; i<30; i++) {
                    const v = dataArray[i*8]; ctx.fillStyle=`hsla(120,100%,50%,${v/255})`;
                    ctx.fillText(String.fromCharCode(33+Math.random()*90), (w/30)*i, (v/255)*h);
                }
            } else if(mode === 8) { // DNA Strand
                for(let i=0; i<40; i++) {
                    const y = (h/40)*i; const off = Math.sin(i*0.3 + hue*0.1)*(dataArray[i%30]*0.8);
                    ctx.fillStyle=`hsla(${hue+i*8},80%,60%,1)`;
                    ctx.beginPath(); ctx.arc(cx+off, y, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx-off, y, 4, 0, Math.PI*2); ctx.fill();
                }
            } else if(mode === 9) { // Tunnel
                for(let i=0; i<15; i++) {
                    const v = dataArray[i*12]/2; ctx.strokeStyle=`hsla(${hue+i*15},70%,50%,0.5)`;
                    ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(cx,cy, i*25 + v, 0, Math.PI*2); ctx.stroke();
                }
            } else if(mode === 10) { // Orbit
                for(let i=0; i<50; i++) {
                    const a = (hue*0.02) + (i*0.5); const r = (dataArray[i]/255)*cx;
                    ctx.fillStyle=`hsla(${hue-i*2},80%,60%,0.8)`;
                    ctx.beginPath(); ctx.arc(cx+Math.cos(a)*r, cy+Math.sin(a)*(r*0.5), 3, 0, Math.PI*2); ctx.fill();
                }
            } else if(mode === 11) { // Solid Peak
                ctx.beginPath(); ctx.fillStyle=`hsla(${hue},80%,40%,0.3)`;
                ctx.moveTo(0,h);
                for(let i=0; i<dataArray.length; i++) {
                    ctx.lineTo((i/dataArray.length)*w, h-(dataArray[i]/255)*h*0.6);
                }
                ctx.lineTo(w,h); ctx.fill();
            }
        }
    </script>
</body>
</html>
