<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visualizer Pro - Ultra Edition 2.0</title>
    <style>
        :root { --accent: #00f2ff; --bg: #050505; --glass: rgba(255, 255, 255, 0.08); }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); overflow: hidden; font-family: 'Inter', sans-serif;
            touch-action: none; color: white; cursor: none; /* Hide cursor by default */
        }
        
        /* Zeige Cursor nur wenn UI aktiv ist */
        body.ui-active { cursor: default; }

        canvas { position: absolute; top: 0; left: 0; display: block; width: 100%; height: 100%; }

        /* UI Container */
        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(20px);
            display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; 
            z-index: 100; background: rgba(0, 0, 0, 0.6); padding: 12px; 
            border-radius: 20px; backdrop-filter: blur(20px);
            width: 95%; max-width: 800px;
            opacity: 0; pointer-events: none; transition: all 0.4s ease-in-out;
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        /* Wenn UI aktiv ist */
        body.ui-active .ui-layer { opacity: 1; pointer-events: auto; transform: translateX(-50%) translateY(0); }

        button {
            background: var(--glass); border: 1px solid rgba(255,255,255,0.05); color: #ccc;
            padding: 8px 12px; border-radius: 8px; cursor: pointer; 
            font-size: 10px; flex: 1 1 auto; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s; min-width: 60px;
        }
        
        button:hover { background: rgba(255,255,255,0.15); color: white; }
        
        button.active { 
            background: var(--accent); color: #000; font-weight: 800; 
            box-shadow: 0 0 15px var(--accent); border-color: var(--accent);
        }
        
        button.special { 
            background: rgba(255, 0, 100, 0.2); color: #ff0066; border: 1px solid #ff0066; 
        }
        button.special.active {
            background: #ff0066; color: white; box-shadow: 0 0 15px #ff0066;
        }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 200;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }
        
        .btn-main {
            background: transparent; color: var(--accent); padding: 20px 50px; 
            border-radius: 50px; font-weight: 300; font-size: 24px; 
            border: 2px solid var(--accent); cursor: pointer; letter-spacing: 4px;
            transition: 0.3s; box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
        }
        .btn-main:hover { background: var(--accent); color: black; box-shadow: 0 0 50px var(--accent); }

        .info { margin-top: 20px; opacity: 0.4; font-size: 10px; letter-spacing: 2px; text-align: center;}
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="letter-spacing: 10px; font-weight: 100; font-size: 3rem; margin-bottom: 40px; text-shadow: 0 0 20px rgba(255,255,255,0.5);">SONIC FLUX</h1>
        <button class="btn-main" onclick="initApp()">INITIALIZE</button>
        <div class="info">
            MICROPHONE ACCESS REQUIRED<br>DOUBLE CLICK FOR FULLSCREEN
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <div id="mode-buttons" style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; width: 100%;"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // --- CONFIG ---
        const FFT_SIZE = 512; // Balance zwischen Performance und Detail
        const SMOOTHING = 0.2; // 0 = kein Smoothing, 0.9 = sehr träge
        
        let audioCtx, analyser, source;
        let dataArray = new Uint8Array(FFT_SIZE / 2);
        let smoothArray = new Float32Array(FFT_SIZE / 2); // Für weiche Animationen
        
        let mode = 0;
        let hue = 0;
        let frame = 0;
        let isFilmMode = false;
        let filmInterval;
        let uiTimeout;

        // Visualisierungen Definition
        const visuals = [
            { name: "Equalizer", draw: drawEqualizer },
            { name: "Circular", draw: drawCircular },
            { name: "Synth Grid", draw: drawSynthGrid },
            { name: "Nebula", draw: drawNebula },
            { name: "Hexagon", draw: drawHexagon },
            { name: "Shockwave", draw: drawShockwave },
            { name: "Black Hole", draw: drawBlackHole },
            { name: "String Theory", draw: drawStrings },
            { name: "Tunnel", draw: drawTunnel },
            { name: "Particles", draw: drawParticles },
            { name: "Oscilloscope", draw: drawScope },
            { name: "Matrix Rain", draw: drawMatrix }
        ];

        // --- SETUP ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // UI Generierung
        const btnContainer = document.getElementById('mode-buttons');
        visuals.forEach((v, i) => {
            const btn = document.createElement('button');
            btn.innerText = v.name;
            btn.id = `btn-${i}`;
            btn.onclick = (e) => { e.stopPropagation(); setMode(i); };
            btnContainer.appendChild(btn);
        });

        const filmBtn = document.createElement('button');
        filmBtn.innerText = "AUTO PILOT";
        filmBtn.classList.add('special');
        filmBtn.onclick = (e) => { e.stopPropagation(); toggleFilmMode(); };
        btnContainer.appendChild(filmBtn);

        // --- AUDIO INIT ---
        async function initApp() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0.85; // Hardware smoothing
                
                source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                
                document.getElementById('start-screen').style.opacity = '0';
                setTimeout(() => document.getElementById('start-screen').style.display = 'none', 500);
                
                if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(()=>{});
                
                triggerUI();
                loop();
            } catch (err) {
                alert("Mikrofon Zugriff notwendig für Visualisierung!");
            }
        }

        // --- CORE LOOP ---
        function loop() {
            requestAnimationFrame(loop);
            
            // Daten holen
            analyser.getByteFrequencyData(dataArray);
            
            // Manuelles Smoothing berechnen (lerp)
            // Das sorgt dafür, dass die Balken nicht springen, sondern gleiten
            for(let i = 0; i < dataArray.length; i++) {
                smoothArray[i] = lerp(smoothArray[i], dataArray[i], SMOOTHING);
            }

            // Hintergrund mit Transparenz für Trail-Effekt
            ctx.fillStyle = 'rgba(5, 5, 5, 0.25)'; // Der Alpha-Wert (0.25) bestimmt die Länge der Trails
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            hue += 0.3;
            frame++;

            // Zeichnen
            ctx.save();
            visuals[mode].draw(canvas.width, canvas.height, canvas.width/2, canvas.height/2);
            ctx.restore();
        }

        // --- HELPER MATH ---
        function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
        function map(value, start1, stop1, start2, stop2) { return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1)); }
        function getBass() { return smoothArray.slice(0, 10).reduce((a,b)=>a+b,0) / 10 / 255; } // 0.0 bis 1.0

        // --- INTERACTION ---
        function setMode(m) {
            mode = m;
            isFilmMode = false;
            clearInterval(filmInterval);
            updateUI();
        }

        function toggleFilmMode() {
            isFilmMode = !isFilmMode;
            if(isFilmMode) {
                filmInterval = setInterval(() => {
                    mode = (mode + 1) % visuals.length;
                    updateUI();
                }, 8000);
            } else {
                clearInterval(filmInterval);
            }
            updateUI();
        }

        function updateUI() {
            visuals.forEach((_, i) => document.getElementById(`btn-${i}`).classList.toggle('active', mode === i));
            filmBtn.classList.toggle('active', isFilmMode);
        }

        // Intelligente UI Steuerung
        function triggerUI() {
            document.body.classList.add('ui-active');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => {
                document.body.classList.remove('ui-active');
            }, 3000);
        }

        window.addEventListener('mousemove', triggerUI);
        window.addEventListener('touchstart', triggerUI);
        window.addEventListener('click', triggerUI);
        window.addEventListener('dblclick', () => {
            if(!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        });

        // --- VISUALIZATION DRAWING FUNCTIONS ---

        function drawEqualizer(w, h, cx, cy) {
            const barWidth = w / 100;
            const bass = getBass();
            
            for(let i=0; i<100; i++) {
                const val = smoothArray[i] / 255;
                const height = val * h * 0.6;
                const x = i * barWidth;
                
                // Mirror effect
                const hueVal = i * 2 + hue;
                ctx.fillStyle = `hsla(${hueVal}, 100%, 50%, 0.8)`;
                
                // Top bars
                ctx.fillRect(cx + i * barWidth, cy - height/2, barWidth-2, height);
                ctx.fillRect(cx - (i+1) * barWidth, cy - height/2, barWidth-2, height);
                
                // Reflection (lower opacity)
                ctx.fillStyle = `hsla(${hueVal}, 100%, 50%, 0.2)`;
                ctx.fillRect(cx + i * barWidth, cy + height/2 + 5, barWidth-2, height*0.3);
                ctx.fillRect(cx - (i+1) * barWidth, cy + height/2 + 5, barWidth-2, height*0.3);
            }
        }

        function drawCircular(w, h, cx, cy) {
            const bass = getBass();
            const radius = h * 0.2 + (bass * h * 0.1);
            
            ctx.beginPath();
            for (let i = 0; i < 120; i++) {
                const angle = map(i, 0, 120, 0, Math.PI * 2);
                const val = smoothArray[i*2] / 255;
                const r = radius + (val * 150);
                
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 1)`;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Inner glow
            ctx.fillStyle = `hsla(${hue + 180}, 100%, 50%, ${bass * 0.5})`;
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.8, 0, Math.PI*2);
            ctx.fill();
        }

        function drawSynthGrid(w, h, cx, cy) {
            const bass = getBass();
            // Perspective Grid
            const horizon = h * 0.4;
            const speed = (frame * 4) % 100;
            
            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.4)`;
            ctx.lineWidth = 1;
            
            // Vertical lines
            for(let i=-10; i<=10; i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i * 100, h);
                ctx.lineTo(cx + i * 10, horizon);
                ctx.stroke();
            }
            
            // Horizontal lines (moving)
            for(let i=0; i<10; i++) {
                const y = h - (i * 40 + speed) * ((h-horizon)/400);
                if(y < horizon) continue;
                
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
            
            // Sun
            ctx.fillStyle = `hsla(${hue+40}, 100%, 60%, 1)`;
            ctx.beginPath();
            ctx.arc(cx, horizon - 50, 40 + bass * 20, 0, Math.PI*2);
            ctx.fill();
        }

        function drawNebula(w, h, cx, cy) {
            const bass = getBass();
            for(let i=0; i<30; i++) {
                const val = smoothArray[i*5]/255;
                const r = val * h * 0.8;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI*2);
                ctx.strokeStyle = `hsla(${hue + i*5}, 70%, 50%, 0.1)`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Rotating dots
                const angle = frame * 0.02 + i * 0.5;
                ctx.fillStyle = `white`;
                ctx.beginPath();
                ctx.arc(cx + Math.cos(angle)*r, cy + Math.sin(angle)*r, 3, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawHexagon(w, h, cx, cy) {
            const bass = getBass();
            const sides = 6;
            const radius = h * 0.2 + bass * 50;
            
            ctx.translate(cx, cy);
            ctx.rotate(frame * 0.01);
            
            for(let j=0; j<5; j++) {
                ctx.beginPath();
                for(let i=0; i<=sides; i++) {
                    const angle = i * 2 * Math.PI / sides;
                    const mod = smoothArray[i * 10] / 255 * 50;
                    const r = radius + j * 30 + mod;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if(i===0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = `hsla(${hue + j*30}, 100%, 50%, 0.8)`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function drawShockwave(w, h, cx, cy) {
            const bass = getBass();
            
            if(bass > 0.6) {
                ctx.strokeStyle = `hsla(${hue}, 100%, 80%, ${bass})`;
                ctx.lineWidth = bass * 50;
                ctx.beginPath();
                ctx.arc(cx, cy, h*0.4, 0, Math.PI*2);
                ctx.stroke();
            }
            
            // Spiral data
            ctx.beginPath();
            for(let i=0; i<200; i++) {
                const angle = i * 0.2 + frame * 0.05;
                const rad = i * 2 + smoothArray[i] * 0.5;
                const x = cx + Math.cos(angle) * rad;
                const y = cy + Math.sin(angle) * rad;
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.strokeStyle = `hsla(${hue+120}, 100%, 50%, 1)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawBlackHole(w, h, cx, cy) {
            const bass = getBass();
            
            // Event Horizon
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(cx, cy, 50, 0, Math.PI*2);
            ctx.fill();
            
            ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 1)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, 50 + bass * 20, 0, Math.PI*2);
            ctx.stroke();
            
            // Accretion Disk
            for(let i=0; i<100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 60 + Math.random() * (h/2);
                const val = smoothArray[i] / 255;
                if(val > 0.1) {
                    const x = cx + Math.cos(angle + frame*0.05) * dist;
                    const y = cy + Math.sin(angle + frame*0.05) * dist * 0.4; // flatten y for 3d effect
                    
                    ctx.fillStyle = `hsla(${hue+i}, 100%, 60%, ${val})`;
                    ctx.beginPath();
                    ctx.arc(x, y, val*5, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        function drawStrings(w, h, cx, cy) {
             for(let i=0; i<20; i++) {
                 ctx.beginPath();
                 ctx.strokeStyle = `hsla(${hue + i*10}, 80%, 50%, 0.5)`;
                 ctx.lineWidth = 2;
                 
                 for(let x=0; x<w; x+=20) {
                     const idx = Math.floor((x/w) * 100);
                     const y = h/2 + Math.sin(x*0.01 + frame*0.05 + i) * (smoothArray[idx]*1.5);
                     if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                 }
                 ctx.stroke();
             }
        }

        function drawTunnel(w, h, cx, cy) {
            const bass = getBass();
            const rings = 15;
            
            for(let i=0; i<rings; i++) {
                const z = (frame * 2 + i * 50) % 800;
                const perspective = 300 / (800 - z);
                const radius = 200 * perspective + (bass * 50 * perspective);
                
                ctx.strokeStyle = `hsla(${hue + i*15}, 100%, 50%, ${perspective})`;
                ctx.lineWidth = 5 * perspective;
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI*2);
                ctx.stroke();
            }
        }
        
        // Simples Partikelsystem
        let particles = [];
        function drawParticles(w, h, cx, cy) {
            const bass = getBass();
            // Emitter
            if(bass > 0.2) {
                for(let i=0; i<5; i++) {
                    particles.push({
                        x: cx, y: cy,
                        vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                        life: 1.0, hue: hue
                    });
                }
            }
            
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= 0.02;
                
                ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, 3 * p.life + bass*2, 0, Math.PI*2); ctx.fill();
                
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawScope(w, h, cx, cy) {
             analyser.getByteTimeDomainData(dataArray);
             ctx.lineWidth = 3;
             ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 1)`;
             ctx.shadowBlur = 10;
             ctx.shadowColor = ctx.strokeStyle;
             
             ctx.beginPath();
             const sliceWidth = w * 1.0 / dataArray.length;
             let x = 0;
             for(let i = 0; i < dataArray.length; i++) {
                 const v = dataArray[i] / 128.0;
                 const y = v * h/2;
                 if(i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                 x += sliceWidth;
             }
             ctx.stroke();
             ctx.shadowBlur = 0;
        }

        function drawMatrix(w, h, cx, cy) {
             ctx.font = "16px monospace";
             const cols = Math.floor(w / 20);
             for(let i = 0; i < cols; i++) {
                 const val = smoothArray[i % 50]; // Reuse audio data for "randomness"
                 const len = Math.floor(val / 10);
                 
                 ctx.fillStyle = `hsla(120, 100%, 50%, 0.8)`;
                 for(let j=0; j<len; j++) {
                     ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), i*20, (frame*2 + j*20) % h);
                 }
             }
        }

    </script>
</body>
</html>
