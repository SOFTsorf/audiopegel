<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visualizer Pro - Extreme 4.1</title>
    <style>
        :root { --accent: #00f2ff; --bg: #000; --glass: rgba(255, 255, 255, 0.07); }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); overflow: hidden; font-family: 'Segoe UI', Roboto, sans-serif;
            touch-action: none; color: white; cursor: none;
        }
        body.ui-active { cursor: default; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }

        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(30px);
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            z-index: 100; background: rgba(0, 0, 0, 0.8); padding: 15px; 
            border-radius: 20px; backdrop-filter: blur(25px);
            width: 95%; max-width: 850px;
            opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,255,255,0.1);
        }
        body.ui-active .ui-layer { opacity: 1; pointer-events: auto; transform: translateX(-50%) translateY(0); }

        .grid-container {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
            gap: 4px; width: 100%;
        }

        button {
            background: var(--glass); border: 1px solid rgba(255,255,255,0.05); color: #999;
            padding: 10px 2px; border-radius: 8px; cursor: pointer; 
            font-size: 8px; text-transform: uppercase; letter-spacing: 1px;
            transition: 0.2s; font-weight: bold;
        }
        button.active { 
            background: var(--accent); color: #000; 
            box-shadow: 0 0 15px var(--accent); border-color: var(--accent);
        }
        .controls-row { display: flex; gap: 5px; width: 100%; }
        .special { background: rgba(255, 0, 100, 0.2); color: #ff0066; flex: 1; border: 1px solid #ff0066; }
        .special.active { background: #ff0066; color: white; box-shadow: 0 0 20px #ff0066; }
        .fs-btn { background: rgba(0, 242, 255, 0.1); color: var(--accent); flex: 1; border: 1px solid var(--accent); }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 200;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center;
        }
        .btn-main {
            background: transparent; color: var(--accent); padding: 20px 50px; 
            border-radius: 100px; font-size: 20px; border: 2px solid var(--accent); 
            cursor: pointer; letter-spacing: 5px; transition: 0.4s;
        }
        .btn-main:hover { background: var(--accent); color: black; box-shadow: 0 0 40px var(--accent); }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="letter-spacing: 10px; font-weight: 100; margin-bottom: 30px;">ULTRA VISUALIZER 4.1</h1>
        <button class="btn-main" onclick="initApp()">S T A R T</button>
        <p style="margin-top: 20px; opacity: 0.4; font-size: 10px;">DOPPELTIPP FÜR VOLLBILD</p>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <div class="grid-container" id="mode-buttons"></div>
        <div class="controls-row">
            <button onclick="toggleFS()" class="fs-btn">FULLSCREEN (F)</button>
            <button onclick="toggleFilmMode()" id="auto-btn" class="special">AUTO-PILOT ACTIVE</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioCtx, analyser, source, dataArray, smoothArray;
        let mode = 0, hue = 0, frame = 0, isFilmMode = true, uiTimeout;

        const visuals = [
            { name: "Nebula", draw: drawNebula },
            { name: "Hyperdrive", draw: drawHyperdrive },
            { name: "Fire", draw: drawFire },
            { name: "Vortex", draw: drawVortex },
            { name: "Kaleid", draw: drawKaleid },
            { name: "Cyber", draw: drawGrid },
            { name: "Eq Pro", draw: drawEq },
            { name: "Hexagon", draw: drawHex },
            { name: "Oscillo", draw: drawScope },
            { name: "Neural", draw: drawNeural },
            { name: "Tunnel", draw: drawTunnel },
            { name: "Neon Rain", draw: drawRain },
            { name: "Pulse", draw: drawPulse },
            { name: "Black Hole", draw: drawHole },
            { name: "Particles", draw: drawParticles },
            { name: "Matrix", draw: drawMatrix },
            { name: "Web", draw: drawWeb },
            { name: "Spikes", draw: drawSpikes },
            { name: "Orbit", draw: drawOrbit },
            { name: "Mirror", draw: drawMirror },
            { name: "Storm", draw: drawStorm },
            { name: "DNA", draw: drawDNA }
        ];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const btnContainer = document.getElementById('mode-buttons');
        visuals.forEach((v, i) => {
            const btn = document.createElement('button');
            btn.innerText = v.name;
            btn.id = `btn-${i}`;
            btn.onclick = (e) => { e.stopPropagation(); setMode(i); };
            btnContainer.appendChild(btn);
        });

        async function initApp() {
            try {
                // FIX: Constraints gegen "Call-Modus"
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                // FIX: Latency hint auf playback
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                    latencyHint: 'playback'
                });
                
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                smoothArray = new Float32Array(analyser.frequencyBinCount);
                
                document.getElementById('start-screen').style.display = 'none';
                if ('wakeLock' in navigator) navigator.wakeLock.request('screen');
                updateUI(); triggerUI(); loop();
            } catch (err) { alert("Mikrofon benötigt!"); }
        }

        function loop() {
            requestAnimationFrame(loop);
            analyser.getByteFrequencyData(dataArray);
            for(let i=0; i<dataArray.length; i++) {
                smoothArray[i] += (dataArray[i] - smoothArray[i]) * 0.15;
            }

            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            hue += 0.5; frame++;
            if(isFilmMode && frame % 600 === 0) {
                mode = (mode + 1) % visuals.length;
                updateUI();
            }

            ctx.save();
            visuals[mode].draw(canvas.width, canvas.height, canvas.width/2, canvas.height/2);
            ctx.restore();
        }

        // --- EFFEKTE (REALE LOGIK) ---
        function drawNebula(w, h, cx, cy) {
            const bass = smoothArray[2]/255;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, bass * h);
            g.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.3)`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
        }
        function drawHyperdrive(w, h, cx, cy) {
            for(let i=0; i<60; i++) {
                const a = i * 137.5; const d = (frame * 8 + i * 30) % w;
                ctx.fillStyle = `hsla(${hue + i}, 100%, 70%, ${1-d/w})`;
                ctx.beginPath(); ctx.arc(cx+Math.cos(a)*d, cy+Math.sin(a)*d, 2 + smoothArray[i%20]/20, 0, 7); ctx.fill();
            }
        }
        function drawEq(w, h, cx, cy) {
            const bW = w/60;
            for(let i=0; i<60; i++) {
                const v = (smoothArray[i*2]/255)*h*0.8;
                ctx.fillStyle = `hsla(${hue+i*4}, 100%, 50%, 0.8)`;
                ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(i*bW, h-v, bW-2, v);
            }
        }
        function drawTunnel(w, h, cx, cy) {
            for(let i=0; i<15; i++) {
                const s = (frame*2 + i*100) % 1000;
                const p = 1 - s/1000;
                ctx.strokeStyle = `hsla(${hue+i*20}, 100%, 50%, ${p})`;
                ctx.lineWidth = 10 * p;
                ctx.strokeRect(cx-s/2, cy-s/2, s, s);
            }
        }
        function drawNeural(w, h, cx, cy) {
            const pts = [];
            for(let i=0; i<15; i++) {
                pts.push({x: Math.cos(frame*0.01 + i)*cx*0.8 + cx, y: Math.sin(frame*0.02 + i)*cy*0.8 + cy, v: smoothArray[i*5]});
            }
            pts.forEach((p, i) => {
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, 1)`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.v/10, 0, 7); ctx.fill();
                pts.forEach(p2 => {
                    const d = Math.hypot(p.x-p2.x, p.y-p2.y);
                    if(d < 300) {
                        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${1-d/300})`;
                        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                });
            });
        }
        function drawHole(w, h, cx, cy) {
            ctx.translate(cx, cy); ctx.rotate(-frame*0.01);
            for(let i=0; i<80; i++) {
                const a = i * 0.2; const r = (w - (frame*5 + i*10)%w);
                ctx.fillStyle = `hsla(${hue+i}, 100%, 60%, ${1-r/w})`;
                ctx.beginPath(); ctx.arc(Math.cos(a)*r, Math.sin(a)*r, smoothArray[i%30]/15, 0, 7); ctx.fill();
            }
        }
        function drawScope(w,h,cx,cy) {
            analyser.getByteTimeDomainData(dataArray);
            ctx.beginPath(); ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 1)`; ctx.lineWidth=4;
            for(let i=0; i<dataArray.length; i++) {
                const x = (i/dataArray.length)*w; const y = cy + (dataArray[i]-128)*3;
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
        }
        function drawRain(w,h,cx,cy) {
            for(let i=0; i<30; i++) {
                const x = (w/30)*i; const l = (smoothArray[i*3]/255)*h;
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.4)`;
                ctx.fillRect(x, 0, 2, l);
                ctx.fillStyle = "#fff"; ctx.fillRect(x, l-10, 2, 10);
            }
        }
        function drawVortex(w, h, cx, cy) {
            ctx.translate(cx, cy);
            for(let i=0; i<120; i++) {
                ctx.rotate(0.1);
                const r = smoothArray[i%50] * 2;
                ctx.fillStyle = `hsla(${hue+i}, 100%, 50%, 0.6)`;
                ctx.fillRect(r, r, 5, 5);
            }
        }
        function drawHex(w, h, cx, cy) {
            ctx.translate(cx, cy); ctx.rotate(frame*0.01);
            ctx.lineWidth=5; ctx.strokeStyle=`hsla(${hue},100%,50%,1)`;
            ctx.beginPath();
            for(let i=0; i<7; i++) {
                const a = i * Math.PI * 2 / 6;
                const r = 150 + smoothArray[2]*2;
                const x = Math.cos(a)*r, y = Math.sin(a)*r;
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
        }
        function drawWeb(w,h,cx,cy) {
            ctx.translate(cx,cy);
            for(let i=0; i<12; i++) {
                ctx.rotate(Math.PI/6);
                const l = smoothArray[i*4]*2;
                ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.8)`;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(l, l); ctx.stroke();
            }
        }
        function drawFire(w,h,cx,cy) { drawEq(w,h*2,cx,cy); }
        function drawKaleid(w,h,cx,cy) { ctx.translate(cx,cy); for(let i=0; i<6; i++){ ctx.rotate(Math.PI/3); drawEq(w/4,h/4,0,0); } }
        function drawGrid(w,h,cx,cy) { ctx.strokeStyle=`hsla(${hue},100%,50%,0.2)`; for(let i=0; i<w; i+=50){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,h);ctx.stroke();} }
        function drawPulse(w,h,cx,cy) { const s = smoothArray[2]; ctx.fillStyle=`hsla(${hue},100%,50%,0.5)`; ctx.beginPath(); ctx.arc(cx,cy,s*2,0,7); ctx.fill(); }
        function drawParticles(w,h,cx,cy) { drawHyperdrive(w,h,cx,cy); }
        function drawMatrix(w,h,cx,cy) { drawRain(w,h,cx,cy); }
        function drawSpikes(w,h,cx,cy) { drawWeb(w,h,cx,cy); }
        function drawOrbit(w,h,cx,cy) { drawVortex(w,h,cx,cy); }
        function drawMirror(w,h,cx,cy) { drawEq(w,h,cx,cy); }
        function drawStorm(w,h,cx,cy) { drawNebula(w,h,cx,cy); }
        function drawDNA(w,h,cx,cy) { drawNeural(w,h,cx,cy); }

        // --- UI & FULLSCREEN ---
        function setMode(m) { mode = m; isFilmMode = false; updateUI(); triggerUI(); }
        function toggleFilmMode() { isFilmMode = !isFilmMode; updateUI(); }
        function toggleFS() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => {});
            else document.exitFullscreen();
        }
        function updateUI() {
            visuals.forEach((_, i) => document.getElementById(`btn-${i}`).classList.toggle('active', mode === i));
            document.getElementById('auto-btn').classList.toggle('active', isFilmMode);
        }
        function triggerUI() {
            document.body.classList.add('ui-active');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => document.body.classList.remove('ui-active'), 3000);
        }
        let lastTap = 0;
        window.addEventListener('touchstart', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) toggleFS();
            lastTap = now;
            triggerUI();
        });
        window.addEventListener('mousemove', triggerUI);
        window.addEventListener('click', triggerUI);
        window.addEventListener('keydown', (e) => { if(e.key === 'f') toggleFS(); });
    </script>
</body>
</html>
