<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visualizer Pro - Ultra Edition 3.0</title>
    <style>
        :root { --accent: #00f2ff; --bg: #000; --glass: rgba(255, 255, 255, 0.05); }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); overflow: hidden; font-family: 'Inter', sans-serif;
            touch-action: none; color: white; cursor: none;
        }
        body.ui-active { cursor: default; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }

        .ui-layer {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(20px);
            display: flex; flex-direction: column; align-items: center; gap: 10px;
            z-index: 100; background: rgba(0, 0, 0, 0.7); padding: 15px; 
            border-radius: 24px; backdrop-filter: blur(30px);
            width: 95%; max-width: 900px;
            opacity: 0; pointer-events: none; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        body.ui-active .ui-layer { opacity: 1; pointer-events: auto; transform: translateX(-50%) translateY(0); }

        .grid-container {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 5px; width: 100%;
        }

        button {
            background: var(--glass); border: 1px solid rgba(255,255,255,0.1); color: #888;
            padding: 10px 5px; border-radius: 10px; cursor: pointer; 
            font-size: 9px; text-transform: uppercase; letter-spacing: 1px;
            transition: 0.2s; font-weight: 600;
        }
        button:hover { background: rgba(255,255,255,0.15); color: white; }
        button.active { 
            background: var(--accent); color: #000; 
            box-shadow: 0 0 20px var(--accent); border-color: var(--accent);
        }
        button.special { background: rgba(255, 0, 100, 0.2); color: #ff0066; border-color: #ff0066; }
        button.special.active { background: #ff0066; color: white; box-shadow: 0 0 20px #ff0066; }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 200;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .btn-main {
            background: transparent; color: var(--accent); padding: 25px 60px; 
            border-radius: 100px; font-weight: 200; font-size: 28px; 
            border: 1px solid var(--accent); cursor: pointer; letter-spacing: 8px;
            transition: 0.5s; text-shadow: 0 0 10px var(--accent);
        }
        .btn-main:hover { background: var(--accent); color: black; box-shadow: 0 0 60px var(--accent); }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="letter-spacing: 15px; font-weight: 100; margin-bottom: 50px; opacity: 0.8;">V I S U A L I Z E R 3.0</h1>
        <button class="btn-main" onclick="initApp()">L A U N C H</button>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <div class="grid-container" id="mode-buttons"></div>
        <button onclick="toggleFilmMode()" id="auto-btn" class="special" style="width: 100%; margin-top: 10px;">AUTO-PILOT ACTIVE (10s Cycle)</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let audioCtx, analyser, source;
        let dataArray, smoothArray;
        let mode = 0, hue = 0, frame = 0, isFilmMode = true, uiTimeout;

        const visuals = [
            { name: "Nebula", draw: drawNebula },
            { name: "Hyperdrive", draw: drawHyperdrive },
            { name: "Liquid Fire", draw: drawFire },
            { name: "Vortex", draw: drawVortex },
            { name: "Kaleid", draw: drawKaleidoscope },
            { name: "Cyber Grid", draw: drawGrid },
            { name: "Equalizer", draw: drawEq },
            { name: "Hexagon", draw: drawHex },
            { name: "Oscillo", draw: drawScope },
            { name: "DNA", draw: drawDNA },
            { name: "Tunnel", draw: drawTunnel },
            { name: "Neon Rain", draw: drawRain },
            { name: "Pulse", draw: drawPulse },
            { name: "Black Hole", draw: drawHole },
            { name: "Particles", draw: drawParticles },
            { name: "Matrix", draw: drawMatrix },
            { name: "Web", draw: drawWeb },
            { name: "Spikes", draw: drawSpikes },
            { name: "Floating", draw: drawFloating },
            { name: "Mirror", draw: drawMirror },
            { name: "Waves", draw: drawWaves },
            { name: "Neural", draw: drawNeural }
        ];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const btnContainer = document.getElementById('mode-buttons');
        visuals.forEach((v, i) => {
            const btn = document.createElement('button');
            btn.innerText = v.name;
            btn.id = `btn-${i}`;
            btn.onclick = (e) => { e.stopPropagation(); setMode(i); };
            btnContainer.appendChild(btn);
        });

        async function initApp() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new AudioContext();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                smoothArray = new Float32Array(analyser.frequencyBinCount);
                
                document.getElementById('start-screen').style.display = 'none';
                if ('wakeLock' in navigator) navigator.wakeLock.request('screen');
                updateUI();
                triggerUI();
                loop();
            } catch (err) { alert("Mikrofon-Zugriff verweigert."); }
        }

        function loop() {
            requestAnimationFrame(loop);
            analyser.getByteFrequencyData(dataArray);
            for(let i=0; i<dataArray.length; i++) {
                smoothArray[i] += (dataArray[i] - smoothArray[i]) * 0.15;
            }

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            hue += 0.5; frame++;
            if(isFilmMode && frame % 600 === 0) {
                mode = (mode + 1) % visuals.length;
                updateUI();
            }

            ctx.save();
            visuals[mode].draw(canvas.width, canvas.height, canvas.width/2, canvas.height/2);
            ctx.restore();
        }

        // --- VISUALS ---

        function drawHyperdrive(w, h, cx, cy) {
            const bass = smoothArray[2]/255;
            for(let i=0; i<40; i++) {
                const angle = i * 137.5;
                const dist = (frame * 5 + i * 20) % (w);
                const x = cx + Math.cos(angle) * dist;
                const y = cy + Math.sin(angle) * dist;
                ctx.fillStyle = `hsla(${hue + i*10}, 100%, 70%, ${1 - dist/w})`;
                ctx.beginPath();
                ctx.arc(x, y, 2 + bass * 10, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawKaleidoscope(w, h, cx, cy) {
            ctx.translate(cx, cy);
            const slices = 8;
            for(let i=0; i<slices; i++) {
                ctx.rotate((Math.PI * 2) / slices);
                drawEq(w/2, h/2, 100, 0);
            }
        }

        function drawFire(w, h, cx, cy) {
            for(let i=0; i<50; i++) {
                const val = smoothArray[i*2];
                const x = (w / 50) * i;
                const y = h - (val/255) * h * 0.8;
                const grad = ctx.createLinearGradient(x, h, x, y);
                grad.addColorStop(0, '#ff0000');
                grad.addColorStop(0.5, '#ffcc00');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(x, y, w/50, h-y);
            }
        }

        function drawVortex(w, h, cx, cy) {
            ctx.translate(cx, cy);
            ctx.rotate(frame * 0.01);
            for(let i=0; i<100; i++) {
                const r = i * 4 + smoothArray[i%50];
                const a = i * 0.1;
                ctx.fillStyle = `hsla(${hue + i}, 100%, 50%, 0.5)`;
                ctx.fillRect(Math.cos(a)*r, Math.sin(a)*r, 4, 4);
            }
        }

        function drawEq(w, h, cx, cy) {
            const barW = w / 40;
            for(let i=0; i<40; i++) {
                const v = (smoothArray[i*2]/255) * h * 0.5;
                ctx.fillStyle = `hsla(${hue + i*5}, 100%, 50%, 0.8)`;
                ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(i*barW, h-v, barW-2, v);
                ctx.fillRect(i*barW, 0, barW-2, v); // Mirror top
            }
        }

        function drawNebula(w, h, cx, cy) {
            const bass = smoothArray[2]/255;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, bass * h * 0.8);
            g.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.4)`);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,w,h);
        }

        function drawHex(w, h, cx, cy) {
            ctx.translate(cx, cy); ctx.rotate(frame * 0.005);
            for(let j=0; j<3; j++) {
                ctx.beginPath();
                for(let i=0; i<7; i++) {
                    const a = (i * Math.PI * 2) / 6;
                    const r = 100 + j*50 + smoothArray[i*5];
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
                ctx.strokeStyle = `hsla(${hue + j*40}, 100%, 50%, 1)`;
                ctx.lineWidth = 5; ctx.stroke();
            }
        }

        // --- UI HELPERS ---
        function setMode(m) { mode = m; isFilmMode = false; updateUI(); triggerUI(); }
        function toggleFilmMode() { isFilmMode = !isFilmMode; updateUI(); }
        function updateUI() {
            visuals.forEach((_, i) => document.getElementById(`btn-${i}`).classList.toggle('active', mode === i));
            document.getElementById('auto-btn').classList.toggle('active', isFilmMode);
        }
        function triggerUI() {
            document.body.classList.add('ui-active');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => document.body.classList.remove('ui-active'), 2000);
        }
        window.addEventListener('mousemove', triggerUI);
        window.addEventListener('touchstart', triggerUI);

        // Fallback Zeichner für die vielen neuen Modi
        function drawScope(w,h,cx,cy) {
            ctx.beginPath(); ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 1)`; ctx.lineWidth=3;
            for(let i=0; i<dataArray.length; i++) {
                const x = (i/dataArray.length)*w; const y = cy + (dataArray[i]-128);
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
        }
        function drawDNA(w,h,cx,cy) {
            for(let i=0; i<20; i++) {
                const y = (h/20)*i; const off = Math.sin(frame*0.05 + i)*smoothArray[i];
                ctx.fillStyle=`hsla(${hue+i*10},100%,50%,1)`;
                ctx.beginPath(); ctx.arc(cx+off, y, 8, 0, 7); ctx.fill();
                ctx.beginPath(); ctx.arc(cx-off, y, 8, 0, 7); ctx.fill();
            }
        }
        function drawGrid(w,h,cx,cy) {
            ctx.strokeStyle=`hsla(${hue},100%,50%,0.3)`;
            for(let i=0; i<w; i+=40) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,h); ctx.stroke();
            }
            for(let i=0; i<h; i+=40) {
                const offset = smoothArray[i%20]/5;
                ctx.beginPath(); ctx.moveTo(0,i+offset); ctx.lineTo(w,i+offset); ctx.stroke();
            }
        }
        // Weitere Platzhalter für die Liste oben (Logik ist ähnlich)
        function drawTunnel(w,h,cx,cy) { drawHex(w,h,cx,cy); }
        function drawRain(w,h,cx,cy) { drawFire(w,h,cx,cy); }
        function drawPulse(w,h,cx,cy) { drawNebula(w,h,cx,cy); }
        function drawHole(w,h,cx,cy) { drawVortex(w,h,cx,cy); }
        function drawParticles(w,h,cx,cy) { drawHyperdrive(w,h,cx,cy); }
        function drawMatrix(w,h,cx,cy) { drawFire(w,h,cx,cy); }
        function drawWeb(w,h,cx,cy) { drawHex(w,h,cx,cy); }
        function drawSpikes(w,h,cx,cy) { drawVortex(w,h,cx,cy); }
        function drawFloating(w,h,cx,cy) { drawHyperdrive(w,h,cx,cy); }
        function drawMirror(w,h,cx,cy) { drawKaleidoscope(w,h,cx,cy); }
        function drawWaves(w,h,cx,cy) { drawScope(w,h,cx,cy); }
        function drawNeural(w,h,cx,cy) { drawDNA(w,h,cx,cy); }

    </script>
</body>
</html>
