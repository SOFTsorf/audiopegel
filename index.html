<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visualizer Pro - Always On</title>
    <style>
        :root { --accent: #00f2ff; --bg: #000; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); overflow: hidden; font-family: sans-serif;
            touch-action: none; 
        }
        canvas { position: absolute; top: 0; left: 0; display: block; width: 100%; height: 100%; }

        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; 
            z-index: 10; background: rgba(0, 0, 0, 0.8); padding: 12px; 
            border-radius: 20px; backdrop-filter: blur(20px);
            width: 95%; max-width: 650px;
            transition: all 0.4s ease; border: 1px solid rgba(255,255,255,0.1);
        }

        body.is-fullscreen .ui-layer { opacity: 0; pointer-events: none; transform: translate(-50%, 60px); }
        body.is-fullscreen.show-ui .ui-layer { opacity: 1; pointer-events: auto; transform: translate(-50%, 0); }

        button {
            background: rgba(255,255,255,0.1); border: none; color: #fff;
            padding: 10px; border-radius: 10px; cursor: pointer; 
            font-size: 10px; flex: 1 1 60px; text-transform: uppercase;
        }
        button.active { background: var(--accent); color: #000; font-weight: bold; }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; cursor: pointer; text-align: center;
        }
    </style>
</head>
<body>

    <div id="start-screen" onclick="initApp()">
        <h1 style="letter-spacing: 10px; font-weight: 200;">ULTRA VIZ</h1>
        <p style="color: var(--accent);">TOUCH TO START & KEEP SCREEN ON</p>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <button onclick="setMode(0, event)">Bars</button>
        <button onclick="setMode(1, event)">Wave</button>
        <button onclick="setMode(2, event)">Radial</button>
        <button onclick="setMode(3, event)">Nebula</button>
        <button onclick="setMode(4, event)">Spiral</button>
        <button onclick="setMode(5, event)">Mirror</button>
        <button onclick="setMode(6, event)">Flower</button>
        <button onclick="setMode(7, event)">Matrix</button>
        <button onclick="setMode(8, event)">DNA</button>
        <button onclick="setMode(9, event)">Tunnel</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioCtx, analyser, dataArray, source, wakeLock = null;
        let mode = 0;
        let hue = 0;
        let uiTimeout;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        // Screen Wake Lock: Hält den Bildschirm an
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) { console.log("WakeLock failed"); }
        }

        async function initApp() {
            if (audioCtx) return;
            
            // Wake Lock aktivieren
            await requestWakeLock();

            try {
                // FIX: Telefon-Modus verhindern durch echoCancellation: false
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });

                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.85;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                // WICHTIG: Nicht zurück an die Speaker leiten (kein Feedback/Telefon-Modus)
                source.connect(analyser);

                document.getElementById('start-screen').style.display = 'none';
                draw();
            } catch (err) { alert("Mikrofon-Zugriff verweigert."); }
        }

        window.addEventListener('pointerdown', (e) => {
            if(e.target.tagName !== 'BUTTON' && audioCtx) {
                mode = (mode + 1) % 10;
                updateUI();
            }
            showUI();
        });

        function setMode(m, e) {
            e.stopPropagation();
            mode = m;
            updateUI();
        }

        function updateUI() {
            const btns = document.querySelectorAll('button');
            btns.forEach((b, i) => b.classList.toggle('active', i === mode));
        }

        function showUI() {
            document.body.classList.add('show-ui');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => document.body.classList.remove('show-ui'), 3000);
        }

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);
            const w = window.innerWidth, h = window.innerHeight;
            const cx = w/2, cy = h/2;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, w, h);
            hue += 0.5;

            switch(mode) {
                case 0: // Bars
                    const bw = w / (dataArray.length * 0.6);
                    for(let i=0; i<dataArray.length*0.6; i++) {
                        const val = (dataArray[i]/255)*h*0.8;
                        ctx.fillStyle = `hsla(${hue+i},70%,50%,0.8)`;
                        ctx.fillRect(i*bw, h-val, bw-1, val);
                    }
                    break;
                case 1: // Wave
                    analyser.getByteTimeDomainData(dataArray);
                    ctx.beginPath(); ctx.strokeStyle=`hsla(${hue},100%,60%,1)`; ctx.lineWidth=3;
                    for(let i=0; i<dataArray.length; i++) {
                        const x = (i/dataArray.length)*w;
                        const y = (dataArray[i]/128)*cy;
                        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                    }
                    ctx.stroke();
                    break;
                case 2: // Radial
                    for(let i=0; i<180; i++) {
                        const a = i * Math.PI/90;
                        const l = (dataArray[i]/255)*150;
                        ctx.strokeStyle=`hsla(${hue+i},80%,50%,0.8)`; ctx.lineWidth=4;
                        ctx.beginPath(); ctx.moveTo(cx,cy); 
                        ctx.lineTo(cx+Math.cos(a)*(100+l), cy+Math.sin(a)*(100+l)); ctx.stroke();
                    }
                    break;
                case 3: // Nebula
                    const b = dataArray[2]/255;
                    const g = ctx.createRadialGradient(cx,cy,0,cx,cy,b*h);
                    g.addColorStop(0, `hsla(${hue},80%,50%,0.8)`); g.addColorStop(1, 'transparent');
                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,b*h,0,Math.PI*2); ctx.fill();
                    break;
                case 4: // Spiral
                    for(let i=0; i<120; i++) {
                        const a = i*0.2 + hue*0.05; const r = i*4 + dataArray[i%50]*0.2;
                        ctx.fillStyle=`hsla(${hue+i*2},70%,60%,0.8)`;
                        ctx.beginPath(); ctx.arc(cx+Math.cos(a)*r, cy+Math.sin(a)*r, dataArray[i%50]/20+2, 0, Math.PI*2); ctx.fill();
                    }
                    break;
                case 5: // Mirror
                    const mw = (w/2)/(dataArray.length*0.4);
                    for(let i=0; i<dataArray.length*0.4; i++) {
                        const v = (dataArray[i]/255)*cy;
                        ctx.fillStyle=`hsla(${hue+i},70%,50%,0.8)`;
                        ctx.fillRect(cx+i*mw, cy-v/2, mw-1, v); ctx.fillRect(cx-i*mw, cy-v/2, mw-1, v);
                    }
                    break;
                case 6: // Flower
                    ctx.save(); ctx.translate(cx,cy); ctx.rotate(hue*0.01);
                    for(let i=0; i<12; i++) {
                        ctx.rotate(Math.PI/6); const v = dataArray[i*5];
                        ctx.strokeStyle=`hsla(${hue+i*20},80%,60%,0.8)`; ctx.strokeRect(-v/2,-v/2,v,v);
                    }
                    ctx.restore();
                    break;
                case 7: // Matrix
                    ctx.font="15px monospace";
                    for(let i=0; i<40; i++) {
                        const v = dataArray[i*4]; ctx.fillStyle=`hsla(120,100%,50%,${v/255})`;
                        ctx.fillText(Math.floor(Math.random()*9), (w/40)*i, (v/255)*h);
                    }
                    break;
                case 8: // DNA
                    for(let i=0; i<50; i++) {
                        const y = (h/50)*i; const off = Math.sin(i*0.2 + hue*0.1)*(dataArray[i%20]);
                        ctx.fillStyle=`hsla(${hue+i*5},80%,60%,1)`;
                        ctx.beginPath(); ctx.arc(cx+off, y, 5, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(cx-off, y, 5, 0, Math.PI*2); ctx.fill();
                    }
                    break;
                case 9: // Tunnel
                    for(let i=0; i<20; i++) {
                        const v = dataArray[i*10]/2; ctx.strokeStyle=`hsla(${hue+i*10},70%,50%,0.5)`;
                        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx,cy, i*20 + v, 0, Math.PI*2); ctx.stroke();
                    }
                    break;
            }
        }
    </script>
</body>
</html>
