<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Audio Visualizer v3</title>
    <style>
        :root { --accent: #00f2ff; --bg: #000; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); overflow: hidden; font-family: 'Segoe UI', sans-serif;
            touch-action: none; 
        }
        
        canvas { position: absolute; top: 0; left: 0; display: block; width: 100%; height: 100%; }

        /* UI Styling */
        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; 
            z-index: 10; background: rgba(0, 0, 0, 0.75); padding: 12px; 
            border-radius: 24px; backdrop-filter: blur(20px);
            width: 95%; max-width: 600px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255,255,255,0.1);
        }

        body.is-fullscreen .ui-layer { opacity: 0; pointer-events: none; transform: translate(-50%, 60px); }
        /* Zeige UI im Fullscreen bei Mausbewegung */
        body.is-fullscreen.show-ui .ui-layer { opacity: 1; pointer-events: auto; transform: translate(-50%, 0); }

        button {
            background: rgba(255,255,255,0.08); border: none; color: #fff;
            padding: 8px 12px; border-radius: 10px; cursor: pointer; 
            font-size: 11px; flex: 1 1 70px; transition: 0.2s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        button.active { background: var(--accent); color: #000; font-weight: bold; box-shadow: 0 0 15px var(--accent); }
        button.fs-btn { background: rgba(0, 242, 255, 0.2); border: 1px solid var(--accent); }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; cursor: pointer;
        }

        .hint { 
            position: fixed; top: 15px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.3); font-size: 10px; z-index: 5;
            pointer-events: none; text-transform: uppercase; letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div id="start-screen" onclick="setupAudio()">
        <h1 style="letter-spacing: 15px; font-weight: 200; margin-bottom: 10px;">V I Z U A L</h1>
        <p style="color: var(--accent); font-size: 14px;">BERÜHREN ZUM STARTEN</p>
    </div>

    <div class="hint">Display tippen: Modus wechseln | 'F': Fullscreen</div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <button onclick="setMode(0, event)" id="m0">Bars</button>
        <button onclick="setMode(1, event)" id="m1">Wave</button>
        <button onclick="setMode(2, event)" id="m2">Radial</button>
        <button onclick="setMode(3, event)" id="m3">Nebula</button>
        <button onclick="setMode(4, event)" id="m4">Spiral</button>
        <button onclick="setMode(5, event)" id="m5">Mirror</button>
        <button onclick="setMode(6, event)" id="m6">Flower</button>
        <button onclick="setMode(7, event)" id="m7">Matrix</button>
        <button onclick="toggleFS(event)" class="fs-btn">⛶</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioCtx, analyser, dataArray, source;
        let mode = 0;
        let hue = 200;
        let uiTimeout;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        async function setupAudio() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = window.innerWidth < 600 ? 512 : 1024;
                analyser.smoothingTimeConstant = 0.85;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                source.connect(analyser);
                document.getElementById('start-screen').style.display = 'none';
                updateUI();
                draw();
            } catch (err) {
                alert("Mikrofon Zugriff verweigert.");
            }
        }

        // DER FIX FÜR DAS DOPPEL-TAPPING:
        // Wir nutzen nur pointerdown (deckt Touch und Maus ab)
        window.addEventListener('pointerdown', (e) => {
            if(e.target.tagName !== 'BUTTON' && audioCtx) {
                mode = (mode + 1) % 8;
                updateUI();
            }
            showUIInFullscreen();
        });

        function setMode(m, e) {
            if(e) e.stopPropagation();
            mode = m;
            updateUI();
        }

        function updateUI() {
            document.querySelectorAll('button').forEach((b, i) => {
                if(i < 8) b.classList.toggle('active', i === mode);
            });
        }

        function toggleFS(e) {
            if(e) e.stopPropagation();
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.body.classList.add('is-fullscreen');
            } else {
                document.exitFullscreen();
            }
        }

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) document.body.classList.remove('is-fullscreen');
        });

        function showUIInFullscreen() {
            document.body.classList.add('show-ui');
            clearTimeout(uiTimeout);
            uiTimeout = setTimeout(() => document.body.classList.remove('show-ui'), 3000);
        }
        window.addEventListener('mousemove', showUIInFullscreen);

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            const w = window.innerWidth;
            const h = window.innerHeight;
            const centerX = w / 2;
            const centerY = h / 2;

            // Hintergrund-Clearing (vermeidet Rückstände)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.18)';
            ctx.fillRect(0, 0, w, h);

            hue += 0.4;

            if (mode === 0) { // Bars
                const count = dataArray.length * 0.6;
                const bw = w / count;
                for (let i = 0; i < count; i++) {
                    const val = (dataArray[i] / 255) * h * 0.8;
                    ctx.fillStyle = `hsla(${hue + i}, 70%, 50%, 0.8)`;
                    ctx.fillRect(i * bw, h - val, bw - 1, val);
                }
            } 
            else if (mode === 1) { // Oscilloscope Wave
                analyser.getByteTimeDomainData(dataArray);
                ctx.lineWidth = 3;
                ctx.strokeStyle = `hsla(${hue}, 90%, 60%, 1)`;
                ctx.beginPath();
                let slice = w / dataArray.length;
                for(let i=0; i < dataArray.length; i++) {
                    let y = (dataArray[i] / 128.0) * centerY;
                    if(i===0) ctx.moveTo(i * slice, y); else ctx.lineTo(i * slice, y);
                }
                ctx.stroke();
            }
            else if (mode === 2) { // Radial Ring
                const count = dataArray.length * 0.5;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const len = (dataArray[i] / 255) * (w < 600 ? 100 : 200);
                    const r = w < 600 ? 70 : 120;
                    ctx.strokeStyle = `hsla(${hue + i}, 80%, 55%, 0.8)`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(centerX + Math.cos(angle) * r, centerY + Math.sin(angle) * r);
                    ctx.lineTo(centerX + Math.cos(angle) * (r + len), centerY + Math.sin(angle) * (r + len));
                    ctx.stroke();
                }
            }
            else if (mode === 3) { // Nebula
                const bass = dataArray[2] / 255;
                const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, bass * h * 0.6);
                grad.addColorStop(0, `hsla(${hue}, 80%, 50%, 0.7)`);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(centerX, centerY, bass * h * 0.6, 0, Math.PI*2);
                ctx.fill();
            }
            else if (mode === 4) { // Fibonacci Spiral
                for (let i = 0; i < 100; i++) {
                    const val = dataArray[i % 50];
                    const angle = i * 0.2 + (hue * 0.01);
                    const r = (i * 5) + (val * 0.2);
                    ctx.fillStyle = `hsla(${hue + i * 5}, 70%, 60%, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(centerX + Math.cos(angle) * r, centerY + Math.sin(angle) * r, val/20 + 2, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            else if (mode === 5) { // Mirror Peak
                const count = dataArray.length * 0.4;
                const bw = (w / 2) / count;
                for (let i = 0; i < count; i++) {
                    const bh = (dataArray[i] / 255) * centerY;
                    ctx.fillStyle = `hsla(${hue + i*3}, 70%, 50%, 0.8)`;
                    ctx.fillRect(centerX + i * bw, centerY - bh/2, bw - 1, bh);
                    ctx.fillRect(centerX - i * bw, centerY - bh/2, bw - 1, bh);
                }
            }
            else if (mode === 6) { // Flower / Geometric
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(hue * 0.01);
                for(let i=0; i<6; i++) {
                    ctx.rotate(Math.PI / 3);
                    const val = dataArray[i*10] / 2;
                    ctx.strokeStyle = `hsla(${hue + i*40}, 80%, 60%, 0.8)`;
                    ctx.strokeRect(-val/2, -val/2, val, val);
                }
                ctx.restore();
            }
            else if (mode === 7) { // Matrix Rain (Freq based)
                for (let i = 0; i < 30; i++) {
                    const val = dataArray[i * 5];
                    const x = (w / 30) * i;
                    ctx.fillStyle = `hsla(120, 100%, 50%, ${val/255})`;
                    ctx.font = "15px monospace";
                    ctx.fillText(Math.random() > 0.5 ? "1" : "0", x, (val/255) * h);
                }
            }
        }
    </script>
</body>
</html>
