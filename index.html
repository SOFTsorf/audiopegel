<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Audio Visualizer Mobile-Ready</title>
    <style>
        :root { --accent: #00f2ff; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #000; overflow: hidden; font-family: sans-serif;
            touch-action: none; /* Verhindert Zoom-Gesten beim Tappen */
        }
        
        canvas { position: absolute; top: 0; left: 0; display: block; width: 100%; height: 100%; }

        /* UI Styling - Optimiert für Daumen-Bedienung */
        .ui-layer {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; 
            z-index: 10; background: rgba(0, 0, 0, 0.7); padding: 10px; 
            border-radius: 20px; backdrop-filter: blur(15px);
            width: 90%; max-width: 500px;
            transition: all 0.4s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Verstecken im Vollbild */
        body.is-fullscreen .ui-layer { opacity: 0; pointer-events: none; transform: translate(-50%, 50px); }

        button {
            background: rgba(255,255,255,0.1); border: none; color: white;
            padding: 10px 15px; border-radius: 12px; cursor: pointer; 
            font-size: 12px; flex-grow: 1; min-width: 80px;
        }
        button.active { background: var(--accent); color: #000; font-weight: bold; }

        #start-screen {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; padding: 20px;
        }

        .hint { 
            position: fixed; top: 15px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.4); font-size: 11px; z-index: 5;
            pointer-events: none; 
        }
    </style>
</head>
<body>

    <div id="start-screen" onclick="setupAudio()">
        <h1 style="letter-spacing: 5px; font-weight: 300;">AUDIO VIZ</h1>
        <p style="color: var(--accent)">TAP TO START</p>
        <p style="font-size: 12px; opacity: 0.6;">(Mikrofon-Berechtigung erforderlich)</p>
    </div>

    <div class="hint">TAP DISPLAY: WECHSEL | 'F': VOLLBILD</div>

    <canvas id="canvas"></canvas>

    <div class="ui-layer" id="controls">
        <button onclick="changeMode(0, event)" id="m0">Bars</button>
        <button onclick="changeMode(1, event)" id="m1">Wave</button>
        <button onclick="changeMode(2, event)" id="m2">Circle</button>
        <button onclick="changeMode(3, event)" id="m3">Nebula</button>
        <button onclick="toggleFS(event)" style="background: rgba(255,255,255,0.2)">Fullscreen</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioCtx, analyser, dataArray, source;
        let mode = 0;
        let hue = 200;

        // Anpassung an Pixel-Dichte für scharfe Darstellung auf Handys
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        async function setupAudio() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                
                // Auf Handys weniger Datenpunkte für bessere Performance
                analyser.fftSize = window.innerWidth < 600 ? 256 : 512;
                analyser.smoothingTimeConstant = 0.8;
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                source.connect(analyser);
                
                document.getElementById('start-screen').style.display = 'none';
                updateUI();
                draw();
            } catch (err) {
                alert("Mikrofon-Zugriff fehlgeschlagen. Bitte in den Einstellungen erlauben.");
            }
        }

        // Modus-Wechsel durch Tappen auf den Hintergrund
        window.addEventListener('touchstart', handleInteraction);
        window.addEventListener('mousedown', handleInteraction);

        function handleInteraction(e) {
            if(e.target.tagName !== 'BUTTON' && audioCtx) {
                mode = (mode + 1) % 4;
                updateUI();
            }
        }

        function changeMode(newMode, e) {
            e.stopPropagation(); // Verhindert doppelten Wechsel
            mode = newMode;
            updateUI();
        }

        function updateUI() {
            document.querySelectorAll('button').forEach((b, i) => {
                if(i < 4) b.classList.toggle('active', i === mode);
            });
        }

        function toggleFS(e) {
            if(e) e.stopPropagation();
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {});
                document.body.classList.add('is-fullscreen');
            } else {
                document.exitFullscreen();
                document.body.classList.remove('is-fullscreen');
            }
        }

        // Automatische Erkennung wenn Fullscreen per ESC verlassen wird
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) document.body.classList.remove('is-fullscreen');
        });

        window.addEventListener('keydown', e => { if(e.key.toLowerCase() === 'f') toggleFS(); });

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            const w = window.innerWidth;
            const h = window.innerHeight;

            // Hintergrund sauber löschen mit leichtem Fade-Effekt
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, w, h);

            hue += 0.5;
            const centerX = w / 2;
            const centerY = h / 2;

            if (mode === 0) { // Responsive Bars
                const count = dataArray.length * 0.7;
                const barWidth = w / count;
                for (let i = 0; i < count; i++) {
                    const barH = (dataArray[i] / 255) * h * 0.7;
                    ctx.fillStyle = `hsla(${hue + (i * 2)}, 70%, 50%, 0.8)`;
                    ctx.fillRect(i * barWidth, h - barH, barWidth - 1, barH);
                }
            } 
            else if (mode === 1) { // Floating Wave
                analyser.getByteTimeDomainData(dataArray);
                ctx.beginPath();
                ctx.lineWidth = 3;
                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 1)`;
                let slice = w / dataArray.length;
                for(let i=0; i < dataArray.length; i++) {
                    let y = (dataArray[i] / 128.0) * centerY;
                    if(i===0) ctx.moveTo(i * slice, y); else ctx.lineTo(i * slice, y);
                }
                ctx.stroke();
            }
            else if (mode === 2) { // Circle
                const count = dataArray.length * 0.6;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const len = (dataArray[i] / 255) * (w < 600 ? 80 : 150);
                    const r = w < 600 ? 60 : 100;
                    ctx.strokeStyle = `hsla(${hue + i}, 80%, 50%, 0.8)`;
                    ctx.lineWidth = w < 600 ? 3 : 5;
                    ctx.lineCap = "round";
                    ctx.beginPath();
                    ctx.moveTo(centerX + Math.cos(angle) * r, centerY + Math.sin(angle) * r);
                    ctx.lineTo(centerX + Math.cos(angle) * (r + len), centerY + Math.sin(angle) * (r + len));
                    ctx.stroke();
                }
            }
            else if (mode === 3) { // Nebula (Pulse)
                const bass = dataArray[2] / 255;
                const radius = bass * (w < 600 ? 200 : 400);
                const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                grad.addColorStop(0, `hsla(${hue}, 80%, 50%, 0.6)`);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI*2);
                ctx.fill();
            }
        }
    </script>
</body>
</html>
